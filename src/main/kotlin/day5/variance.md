# 변성
제네릭형의 대체가능성
기본타입에서 부모/자식 타입간의 대체를 파라미터 타입에서 하고 싶은 것 
- 무공변 : 타입 끼리 아무 관계가 없다.
```kotlin
val v: Tree<Number> = Tree<Int> // 이게 됐으면 좋겠다
```
- 공변 : 파라미터 타입에서 기본타입의 대체가능성을 따라하는 경우
  - 제네릭이 더 많은 타입을 유연하게 받을 수 있음
  - T가 노출되지 않으면 무엇인지 모르고 그냥 T 로서 만 다루어지는데 아래처럼 밖으로 노출되면 Number 로 사용하기때문에 기본타입의 rule(대체가능성) 을 따라줘야함  
```kotlin
class Tree<out T>(val value: T)
val tree: Tree<Number> = Tree<Int>(10)
tree.value.toDouble() 
```
- Number를 기대하니까 실제 구현체인 Int, Long 뭐를 가져와도 상관이없어서 `읽기는 가능`
- T가 인자로노출되면 실제 구현체는 Int인데 Long같은 것이 들어올수 있어서 `쓰기는 안됌`
- 그래서 out 키워드를 달아서 읽기전용이라고 확신을주고 공변으로 쓸 수 있는 것

